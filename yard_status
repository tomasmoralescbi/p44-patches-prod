//yard status v2
//

(function() {
  // Variables to store authorization and cookie information
  let authorization = '';
  let cookieValue = '';
  let yardData = [];
  let taskData = []; // Store task data
  let modalCreated = false;
  let refreshIntervalId = null;
  let debugMode = true; // Set to true to enable debugging
  let debugPanel = null;
  let sortConfig = { column: null, direction: 'asc' };
  let filters = {};
  let appointmentCache = {}; // Cache appointment data to reduce API calls

  // Debug logging function
  function debugLog(message, data) {
    if (!debugMode) return;
    
    console.log('[YardConsole Debug] ' + message, data || '');
    
    if (debugPanel) {
      const logEntry = document.createElement('div');
      logEntry.style.borderBottom = '1px solid #ccc';
      logEntry.style.padding = '5px';
      
      const timestamp = new Date().toLocaleTimeString();
      logEntry.innerHTML = '<strong>' + timestamp + '</strong>: ' + message;
      
      if (data) {
        const dataStr = typeof data === 'object' ? JSON.stringify(data, null, 2) : data;
        const dataEl = document.createElement('pre');
        dataEl.style.margin = '5px 0';
        dataEl.style.padding = '5px';
        dataEl.style.backgroundColor = '#f5f5f5';
        dataEl.style.maxHeight = '100px';
        dataEl.style.overflow = 'auto';
        dataEl.textContent = dataStr;
        logEntry.appendChild(dataEl);
      }
      
      debugPanel.prepend(logEntry);
      
      // Limit debug entries
      while (debugPanel.children.length > 20) {
        debugPanel.removeChild(debugPanel.lastChild);
      }
    }
  }

  // Create button at the top of the page
  function createButton() {
    const button = document.createElement('button');
    button.id = 'console-button';
    button.textContent = 'Consola de Puerta';
    button.style.cssText = `
      position: fixed;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 10000;
      padding: 10px 15px;
      background-color: #4185f4;
      color: white;
      border: none;
      border-radius: 4px;
      font-size: 16px;
      cursor: pointer;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    `;
    button.onclick = showConsole;
    document.body.appendChild(button);
    
    // Debug button
    const debugButton = document.createElement('button');
    debugButton.id = 'debug-button';
    debugButton.textContent = 'Debug';
    debugButton.style.cssText = `
      position: fixed;
      top: 10px;
      right: 10px;
      z-index: 10000;
      padding: 5px 10px;
      background-color: #ff6347;
      color: white;
      border: none;
      border-radius: 4px;
      font-size: 14px;
      cursor: pointer;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    `;
    debugButton.onclick = toggleDebugPanel;
    document.body.appendChild(debugButton);
    
    debugLog('Buttons created and added to page');
  }

  // Toggle debug panel
  function toggleDebugPanel() {
    if (!debugPanel) {
      createDebugPanel();
    } else {
      debugPanel.style.display = debugPanel.style.display === 'none' ? 'block' : 'none';
    }
  }

  // Create debug panel
  function createDebugPanel() {
    debugPanel = document.createElement('div');
    debugPanel.id = 'yard-debug-panel';
    debugPanel.style.cssText = `
      position: fixed;
      bottom: 10px;
      right: 10px;
      width: 400px;
      height: 300px;
      background-color: white;
      border: 1px solid #ccc;
      box-shadow: 0 2px 10px rgba(0,0,0,0.2);
      z-index: 10002;
      overflow-y: auto;
      padding: 10px;
      font-family: monospace;
      font-size: 12px;
    `;
    
    // Header with controls
    const header = document.createElement('div');
    header.style.cssText = `
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
      padding-bottom: 5px;
      border-bottom: 1px solid #ccc;
    `;
    
    const title = document.createElement('div');
    title.textContent = 'Debug Panel';
    title.style.fontWeight = 'bold';
    
    const controlsDiv = document.createElement('div');
    
    // Manual fetch button
    const fetchButton = document.createElement('button');
    fetchButton.textContent = 'Fetch Data';
    fetchButton.style.marginRight = '5px';
    fetchButton.onclick = () => {
      debugLog('Manual fetch triggered');
      fetchYardData(true);
    };
    
    // Close button
    const closeButton = document.createElement('button');
    closeButton.textContent = 'X';
    closeButton.onclick = () => {
      debugPanel.style.display = 'none';
    };
    
    controlsDiv.appendChild(fetchButton);
    controlsDiv.appendChild(closeButton);
    header.appendChild(title);
    header.appendChild(controlsDiv);
    
    // Status panel
    const statusPanel = document.createElement('div');
    statusPanel.style.cssText = `
      margin-bottom: 10px;
      padding: 5px;
      background-color: #f5f5f5;
      border-radius: 4px;
    `;
    statusPanel.id = 'debug-status-panel';
    
    // Add current status information
    updateDebugStatus(statusPanel);
    
    // Debug log area
    const logArea = document.createElement('div');
    logArea.style.cssText = `
      overflow-y: auto;
      height: calc(100% - 80px);
      border-top: 1px solid #ccc;
      padding-top: 5px;
    `;
    
    debugPanel.appendChild(header);
    debugPanel.appendChild(statusPanel);
    debugPanel.appendChild(logArea);
    document.body.appendChild(debugPanel);
    
    // Set log area as the actual debug panel content area
    debugPanel = logArea;
    
    // Update status every 5 seconds
    setInterval(() => updateDebugStatus(statusPanel), 5000);
    
    debugLog('Debug panel created');
  }

  // Update debug status panel
  function updateDebugStatus(statusPanel) {
    if (!statusPanel) return;
    
    statusPanel.innerHTML = 
      '<div><strong>Authorization:</strong> ' + (authorization ? '‚úÖ Captured' : '‚ùå Missing') + '</div>' +
      '<div><strong>Cookie:</strong> ' + (cookieValue ? '‚úÖ Captured' : '‚ùå Missing') + '</div>' +
      '<div><strong>Yard Data:</strong> ' + yardData.length + ' items</div>' +
      '<div><strong>Task Data:</strong> ' + taskData.length + ' items</div>' +
      '<div><strong>Cached Appointments:</strong> ' + Object.keys(appointmentCache).length + ' items</div>' +
      '<div><strong>Last Update:</strong> ' + new Date().toLocaleTimeString() + '</div>';
  }

  // Format Unix timestamp to day/month HH:MM
  function formatTimestamp(timestamp) {
    if (!timestamp) return '';
    const date = new Date(timestamp);
    return date.getDate() + '/' + (date.getMonth() + 1) + ' ' + 
           String(date.getHours()).padStart(2, '0') + ':' + 
           String(date.getMinutes()).padStart(2, '0');
  }

  // Calculate time difference between two timestamps and return formatted string
  function calculateTimeDifference(timestamp1, timestamp2) {
    if (!timestamp1 || !timestamp2) return '';
    
    const diff = Math.abs(timestamp1 - timestamp2);
    
    const seconds = Math.floor((diff / 1000) % 60);
    const minutes = Math.floor((diff / (1000 * 60)) % 60);
    const hours = Math.floor((diff / (1000 * 60 * 60)));
    
    return String(hours).padStart(2, '0') + ':' + 
           String(minutes).padStart(2, '0');
  }

  // Calculate time difference with current time and return formatted string with appropriate emoji
  function calculateDwellTime(timestamp) {
    if (!timestamp) return '';
    
    const now = Date.now();
    const diff = now - timestamp;
    
    const seconds = Math.floor((diff / 1000) % 60);
    const minutes = Math.floor((diff / (1000 * 60)) % 60);
    const hours = Math.floor((diff / (1000 * 60 * 60)));
    
    const formattedTime = String(hours).padStart(2, '0') + ':' + 
                         String(minutes).padStart(2, '0') + ':' + 
                         String(seconds).padStart(2, '0');
    
    let emoji = '';
    if (diff < 30 * 60 * 1000) { // less than 30 mins
      emoji = 'üòä';
    } else if (diff < 60 * 60 * 1000) { // less than 1 hour
      emoji = 'üòê';
    } else if (diff < 2 * 60 * 60 * 1000) { // less than 2 hours
      emoji = '‚ö†Ô∏è';
    } else if (diff < 4 * 60 * 60 * 1000) { // less than 4 hours
      emoji = '‚õî';
    } else { // more than 4 hours
      emoji = 'üíÄ';
    }
    
    return formattedTime + ' ' + emoji;
  }

  // Get latest task time by type and stage for a specific asset
  function getTaskTimeForAsset(uuid, taskType, timeField) {
    if (!taskData || !taskData.length || !uuid) return null;
    
    // Filter tasks by asset UUID and task type
    const relevantTasks = taskData.filter(task => {
      return task.task_type.code === taskType && 
             task.assets && 
             task.assets.some(asset => asset.uuid === uuid);
    });
    
    if (!relevantTasks.length) return null;
    
    // Sort by the specified time field in descending order
    relevantTasks.sort((a, b) => {
      const timeA = a[timeField] || 0;
      const timeB = b[timeField] || 0;
      return timeB - timeA;  // Most recent first
    });
    
    // Return the time from the most recent task
    return relevantTasks[0][timeField];
  }

  // Function to fetch task data
  function fetchTaskData() {
    return new Promise((resolve, reject) => {
      if (!authorization || !cookieValue) {
        debugLog("Authorization or Cookie not captured yet. Cannot fetch task data.");
        reject(new Error("Authorization or Cookie not captured yet."));
        return;
      }
      
      debugLog("Fetching task data...");
      
      // Create request headers
      const headers = new Headers();
      headers.append('Authorization', authorization);
      headers.append('Cookie', cookieValue);
      
      fetch('https://yard-visibility-na12.api.project44.com/v1/task-search?page_no=1&size=1000&site=obregon', {
        method: 'GET',
        headers: headers,
        credentials: 'include'
      })
      .then(response => {
        if (!response.ok) {
          throw new Error('Task API responded with status ' + response.status);
        }
        return response.json();
      })
      .then(data => {
        debugLog("Task data fetched successfully", { items: data.data?.length || 0 });
        
        if (!data.data) {
          debugLog("API response missing data property", data);
          reject(new Error("API response missing data property"));
          return;
        }
        
        taskData = data.data || [];
        resolve(taskData);
      })
      .catch(error => {
        debugLog("Error fetching task data:", error.message);
        console.error("Error fetching task data:", error);
        reject(error);
      });
    });
  }

  // Get appointment data for a trailer
  function fetchAppointmentData(shipmentNo) {
    return new Promise((resolve, reject) => {
      if (!authorization || !cookieValue) {
        reject(new Error("Authorization or Cookie not captured yet."));
        return;
      }
      
      // Check if we have cached data
      if (appointmentCache[shipmentNo]) {
        resolve(appointmentCache[shipmentNo]);
        return;
      }
      
      debugLog('Fetching appointment data for shipment ' + shipmentNo);
      
      // Create request headers
      const headers = new Headers();
      headers.append('Authorization', authorization);
      headers.append('Cookie', cookieValue);
      
      fetch('https://yard-visibility-na12.api.project44.com/v1/gate/console/search?event_move=arrival&search_term=' + shipmentNo + '&location_type=gate&screen=gate_console&site=obregon', {
        method: 'GET',
        headers: headers,
        credentials: 'include'
      })
      .then(response => {
        if (!response.ok) {
          throw new Error('API responded with status ' + response.status);
        }
        return response.json();
      })
      .then(data => {
        debugLog('Appointment data received for shipment ' + shipmentNo, data);
        
        // Process and cache the data
        if (data.data && data.data.length > 0) {
          const appointmentData = {
            appointmentTime: data.data[0].appointment_information?.appointment_time || null,
            sectionName: data.data[0].appointment_information?.section_name || ''
          };
          
          // Cache the result
          appointmentCache[shipmentNo] = appointmentData;
          resolve(appointmentData);
        } else {
          // Empty result
          appointmentCache[shipmentNo] = { appointmentTime: null, sectionName: '' };
          resolve(appointmentCache[shipmentNo]);
        }
      })
      .catch(error => {
        debugLog('Error fetching appointment data for shipment ' + shipmentNo + ':', error.message);
        reject(error);
      });
    });
  }

  // Extract notification time from the comment field
  function extractNotificationTime(item) {
    if (!item) return null;
    
    // Check for comment in trailer object first
    if (item.trailer && item.trailer.comment) {
      const trailerMatch = item.trailer.comment.match(/<sc>(\d+)<\/sc>/);
      if (trailerMatch) return parseInt(trailerMatch[1]);
    }
    
    // Then check for comment in the main object
    if (item.comment) {
      const match = item.comment.match(/<sc>(\d+)<\/sc>/);
      if (match) return parseInt(match[1]);
    }
    
    return null;
  }

  // Send notification for a trailer
  function sendNotification(item) {
    return new Promise((resolve, reject) => {
      if (!authorization || !cookieValue) {
        reject(new Error("Authorization or Cookie not captured yet."));
        return;
      }
      
      if (!item || !item.uuid) {
        reject(new Error("Invalid item data"));
        return;
      }
      
      debugLog('Fetching asset details for UUID ' + item.uuid);
      
      // Create request headers
      const headers = new Headers();
      headers.append('Authorization', authorization);
      headers.append('Cookie', cookieValue);
      headers.append('Content-Type', 'application/json');
      
      // First, get the current asset data
      fetch('https://yard-visibility-na12.api.project44.com/v1/asset/' + item.uuid, {
        method: 'GET',
        headers: headers,
        credentials: 'include'
      })
      .then(response => {
        if (!response.ok) {
          throw new Error('API responded with status ' + response.status);
        }
        return response.json();
      })
      .then(data => {
        debugLog('Asset details received for UUID ' + item.uuid, data);
        
        // Create a new payload with the structure needed for the PUT request
        const currentTimestamp = Date.now();
        let updatePayload = { ...data }; // Create a copy of the base data
        
        // Add the notification timestamp to the comment
        let comment = '';
        
        // If comment exists in trailer, use that, otherwise use the main comment if it exists
        if (data.trailer && data.trailer.comment) {
          comment = data.trailer.comment;
        } else if (data.comment) {
          comment = data.comment;
        }
        
        // Add the timestamp to the comment
        if (comment.includes('<sc>')) {
          // Replace existing timestamp
          comment = comment.replace(/<sc>.*?<\/sc>/, '<sc>' + currentTimestamp + '</sc>');
        } else {
          // Add new timestamp
          comment = comment + '<sc>' + currentTimestamp + '</sc>';
        }
        
        // Set trailer to empty string as in the example
        updatePayload.trailer = '';
        
        // Move trailer properties to the main object
        if (data.trailer && typeof data.trailer === 'object') {
          // Add all trailer properties to the main object
          Object.keys(data.trailer).forEach(key => {
            updatePayload[key] = data.trailer[key];
          });
        }
        
        // Set the comment with the timestamp
        updatePayload.comment = comment;
        
        // Add other required properties shown in the example
        updatePayload.assignedSiteFlag = false;
        updatePayload.maintenance = {};
        updatePayload.rental = {};
        updatePayload.seal1_intact = false;
        updatePayload.seal2_intact = false;
        updatePayload.seal2 = '';
        updatePayload.rfid = '';
        
        debugLog('Sending notification update for UUID ' + item.uuid);
        
        // Send the update with the transformed structure
        return fetch('https://yard-visibility-na12.api.project44.com/v1/asset/' + item.uuid, {
          method: 'PUT',
          headers: headers,
          credentials: 'include',
          body: JSON.stringify(updatePayload)
        });
      })
      .then(response => {
        if (!response.ok) {
          throw new Error('Update API responded with status ' + response.status);
        }
        return response.json();
      })
      .then(result => {
        debugLog('Notification sent for UUID ' + item.uuid, result);
        
        // Update the item in our local data
        const itemIndex = yardData.findIndex(i => i.uuid === item.uuid);
        if (itemIndex !== -1) {
          const currentTimestamp = Date.now();
          
          // Update the comment in our local data structure
          if (yardData[itemIndex].trailer && yardData[itemIndex].trailer.comment) {
            if (yardData[itemIndex].trailer.comment.includes('<sc>')) {
              yardData[itemIndex].trailer.comment = yardData[itemIndex].trailer.comment.replace(
                /<sc>.*?<\/sc>/, 
                '<sc>' + currentTimestamp + '</sc>'
              );
            } else {
              yardData[itemIndex].trailer.comment = yardData[itemIndex].trailer.comment + '<sc>' + currentTimestamp + '</sc>';
            }
          } 
          else if (yardData[itemIndex].comment) {
            if (yardData[itemIndex].comment.includes('<sc>')) {
              yardData[itemIndex].comment = yardData[itemIndex].comment.replace(
                /<sc>.*?<\/sc>/, 
                '<sc>' + currentTimestamp + '</sc>'
              );
            } else {
              yardData[itemIndex].comment = yardData[itemIndex].comment + '<sc>' + currentTimestamp + '</sc>';
            }
          }
        }
        
        // Update the table
        updateTable();
        resolve(result);
      })
      .catch(error => {
        debugLog('Error sending notification for UUID ' + item.uuid + ':', error.message);
        reject(error);
      });
    });
  }

  // Export table data to Excel
  function exportToExcel() {
    debugLog("Exporting data to Excel");
    
    if (yardData.length === 0) {
      alert("No hay datos para exportar");
      return;
    }
    
    try {
      // Create a workbook
      const wb = XLSX.utils.book_new();
      
      // Prepare the data
      const excelData = [];
      
      // Add headers
      const headers = [
        'Folio', 'Entrega', 'Estado', 'Material', 'Descripci√≥n', 
        'Tipo', 'Ubicaci√≥n actual', 'Linea', 'Nombre operador', 
        'Tel√©fono operador', 'Econ√≥mico tracto', 'Econ√≥mico trailer', 
        'Hora reportado', 'Tiempo de estancia', 'Fecha de la cita',
        'Diferencia vs. cita', 'Secci√≥n cita', 'Aviso enviado',
        'Hora de ingreso', 'Hora de llegada a rampa',
        'Hora de fin de carga/descarga', 'Hora de salida de rampa'
      ];
      excelData.push(headers);
      
      // Filter and sort data according to current settings
      const displayData = getFilteredAndSortedData();
      
      // Add data rows
      displayData.forEach(item => {
        const reference1 = item.trailer && item.trailer.shipment_details ? item.trailer.shipment_details.reference_1 || '' : '';
        const reference2 = item.trailer && item.trailer.shipment_details ? item.trailer.shipment_details.reference_2 || '' : '';
        const status = item.status === 'empty' ? 'Vac√≠o' : item.status === 'loaded' ? 'Cargado' : item.status || '';
        const commodity = item.commodity || '';
        const sku = item.trailer && item.trailer.shipment_details && item.trailer.shipment_details.sku ? 
                    item.trailer.shipment_details.sku.join(', ') : '';
        const serviceType = item.trailer ? item.trailer.service_type || '' : '';
        const location = item.current_location || '';
        const carrier = item.cab ? item.cab.carrier || '' : '';
        const driverName = item.cab ? 
                          (item.cab.first_name || '') + ' ' + (item.cab.last_name || '').trim() : '';
        const driverPhone = item.cab ? item.cab.driver_cell_no || '' : '';
        const cabNo = item.cab ? item.cab.cab_no || '' : '';
        const trailerName = item.name || '';
        const arrivalTime = formatTimestamp(item.arrival_time);
        const timeDifference = calculateDwellTime(item.arrival_time).split(' ')[0]; // Remove emoji for Excel
        
        // Get appointment data
        const shipmentNo = item.trailer?.shipment_no || '';
        const appointmentInfo = appointmentCache[shipmentNo] || { appointmentTime: null, sectionName: '' };
        const appointmentTime = appointmentInfo.appointmentTime ? formatTimestamp(appointmentInfo.appointmentTime) : '';
        const appointmentDiff = (item.arrival_time && appointmentInfo.appointmentTime) ? 
                               calculateTimeDifference(item.arrival_time, appointmentInfo.appointmentTime) : '';
        const sectionName = appointmentInfo.sectionName || '';
        
        // Get notification time
        const notificationTime = extractNotificationTime(item);
        const notificationStatus = notificationTime ? formatTimestamp(notificationTime) : 'No enviado';
        
        // Get task times
        const ingressTime = getTaskTimeForAsset(item.uuid, 'spot', 'created_time');
        const arrivalToRampTime = getTaskTimeForAsset(item.uuid, 'spot', 'completed_time');
        const endLoadingTime = getTaskTimeForAsset(item.uuid, 'pull', 'created_time');
        const exitRampTime = getTaskTimeForAsset(item.uuid, 'pull', 'completed_time');
        
        excelData.push([
          reference1, reference2, status, commodity, sku, serviceType, location,
          carrier, driverName, driverPhone, cabNo, trailerName, arrivalTime, timeDifference,
          appointmentTime, appointmentDiff, sectionName, notificationStatus,
          ingressTime ? formatTimestamp(ingressTime) : '',
          arrivalToRampTime ? formatTimestamp(arrivalToRampTime) : '',
          endLoadingTime ? formatTimestamp(endLoadingTime) : '',
          exitRampTime ? formatTimestamp(exitRampTime) : ''
        ]);
      });
      
      // Create worksheet
      const ws = XLSX.utils.aoa_to_sheet(excelData);
      
      // Add worksheet to workbook
      XLSX.utils.book_append_sheet(wb, ws, "Datos de Patio");
      
      // Generate Excel file and trigger download
      const fileName = 'datos_patio_' + new Date().toISOString().split('T')[0] + '.xlsx';
      XLSX.writeFile(wb, fileName);
      
      debugLog("Excel export completed", { rows: excelData.length - 1 });
    } catch (error) {
      debugLog("Error exporting to Excel:", error.message);
      
      // If XLSX is not loaded, try using a simpler CSV approach
      if (typeof XLSX === 'undefined') {
        exportToCSV();
      } else {
        alert("Error al exportar: " + error.message);
      }
    }
  }
  
  // Fallback CSV export
  function exportToCSV() {
    debugLog("Fallback to CSV export");
    
    try {
      // Prepare the data
      let csvContent = "data:text/csv;charset=utf-8,";
      
      // Add headers
      const headers = [
        'Folio', 'Entrega', 'Estado', 'Material', 'Descripci√≥n', 
        'Tipo', 'Ubicaci√≥n actual', 'Linea', 'Nombre operador', 
        'Tel√©fono operador', 'Econ√≥mico tracto', 'Econ√≥mico trailer', 
        'Hora reportado', 'Tiempo de estancia', 'Fecha de la cita',
        'Diferencia vs. cita', 'Secci√≥n cita', 'Aviso enviado',
        'Hora de ingreso', 'Hora de llegada a rampa',
        'Hora de fin de carga/descarga', 'Hora de salida de rampa'
      ];
      csvContent += headers.join(",") + "\r\n";
      
      // Filter and sort data according to current settings
      const displayData = getFilteredAndSortedData();
      
      // Add data rows
      displayData.forEach(item => {
        const reference1 = item.trailer && item.trailer.shipment_details ? item.trailer.shipment_details.reference_1 || '' : '';
        const reference2 = item.trailer && item.trailer.shipment_details ? item.trailer.shipment_details.reference_2 || '' : '';
        const status = item.status === 'empty' ? 'Vac√≠o' : item.status === 'loaded' ? 'Cargado' : item.status || '';
        const commodity = item.commodity || '';
        const sku = item.trailer && item.trailer.shipment_details && item.trailer.shipment_details.sku ? 
                    item.trailer.shipment_details.sku.join(', ').replace(/,/g, ' -') : '';
        const serviceType = item.trailer ? item.trailer.service_type || '' : '';
        const location = item.current_location || '';
        const carrier = item.cab ? item.cab.carrier || '' : '';
        const driverName = item.cab ? 
                          ((item.cab.first_name || '') + ' ' + (item.cab.last_name || '')).trim() : '';
        const driverPhone = item.cab ? item.cab.driver_cell_no || '' : '';
        const cabNo = item.cab ? item.cab.cab_no || '' : '';
        const trailerName = item.name || '';
        const arrivalTime = formatTimestamp(item.arrival_time);
        const timeDifference = calculateDwellTime(item.arrival_time).split(' ')[0]; // Remove emoji
        
        // Get appointment data
        const shipmentNo = item.trailer?.shipment_no || '';
        const appointmentInfo = appointmentCache[shipmentNo] || { appointmentTime: null, sectionName: '' };
        const appointmentTime = appointmentInfo.appointmentTime ? formatTimestamp(appointmentInfo.appointmentTime) : '';
        const appointmentDiff = (item.arrival_time && appointmentInfo.appointmentTime) ? 
                               calculateTimeDifference(item.arrival_time, appointmentInfo.appointmentTime) : '';
        const sectionName = appointmentInfo.sectionName || '';
        
        // Get notification time
        const notificationTime = extractNotificationTime(item);
        const notificationStatus = notificationTime ? formatTimestamp(notificationTime) : 'No enviado';
        
        // Get task times
        const ingressTime = getTaskTimeForAsset(item.uuid, 'spot', 'created_time');
        const arrivalToRampTime = getTaskTimeForAsset(item.uuid, 'spot', 'completed_time');
        const endLoadingTime = getTaskTimeForAsset(item.uuid, 'pull', 'created_time');
        const exitRampTime = getTaskTimeForAsset(item.uuid, 'pull', 'completed_time');
        
        const row = [
          reference1, reference2, status, commodity, sku, serviceType, location,
          carrier, driverName, driverPhone, cabNo, trailerName, arrivalTime, timeDifference,
          appointmentTime, appointmentDiff, sectionName, notificationStatus,
          ingressTime ? formatTimestamp(ingressTime) : '',
          arrivalToRampTime ? formatTimestamp(arrivalToRampTime) : '',
          endLoadingTime ? formatTimestamp(endLoadingTime) : '',
          exitRampTime ? formatTimestamp(exitRampTime) : ''
        ].map(val => '"' + String(val).replace(/"/g, '""') + '"').join(',');
        
        csvContent += row + "\r\n";
      });
      
      // Create download link
      const encodedUri = encodeURI(csvContent);
      const link = document.createElement("a");
      link.setAttribute("href", encodedUri);
      link.setAttribute("download", 'datos_patio_' + new Date().toISOString().split('T')[0] + '.csv');
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      
      debugLog("CSV export completed");
    } catch (error) {
      debugLog("Error exporting to CSV:", error.message);
      alert("Error al exportar: " + error.message);
    }
  }

  // Load XLSX library if not present
  function loadXLSXLibrary() {
    if (typeof XLSX !== 'undefined') {
      debugLog("XLSX library already loaded");
      return Promise.resolve();
    }
    
    debugLog("Loading XLSX library");
    return new Promise((resolve, reject) => {
      const script = document.createElement('script');
      script.src = 'https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js';
      script.onload = () => {
        debugLog("XLSX library loaded successfully");
        resolve();
      };
      script.onerror = () => {
        debugLog("Failed to load XLSX library");
        reject(new Error("Failed to load Excel export library"));
      };
      document.head.appendChild(script);
    });
  }

  // Make API request to get yard data
  function fetchYardData(manualFetch = false) {
    if (!authorization || !cookieValue) {
      debugLog("Authorization or Cookie not captured yet. Cannot fetch data.", { auth: !!authorization, cookie: !!cookieValue });
      return;
    }
    
    debugLog("Fetching yard data...");
    
    // Use a fallback approach if needed
    if (!manualFetch && yardData.length > 0) {
      debugLog("Using sample data for development");
      // This is just a fallback for development
      updateTable();
      return;
    }
    
    // Create request headers
    const headers = new Headers();
    headers.append('Authorization', authorization);
    headers.append('Cookie', cookieValue);
    
    debugLog("Request headers prepared", {
      Authorization: authorization.substring(0, 20) + '...',
      Cookie: cookieValue.substring(0, 20) + '...'
    });
    
    // Fetch yard data
    const yardDataPromise = fetch('https://yard-visibility-na12.api.project44.com/v1/asset/search?page_no=1&size=1000&assetClass=trailer&in_yard=true&site=obregon', {
      method: 'GET',
      headers: headers,
      credentials: 'include'
    })
    .then(response => {
      debugLog('Response status: ' + response.status);
      if (!response.ok) {
        throw new Error('API responded with status ' + response.status);
      }
      return response.json();
    })
    .then(data => {
      debugLog("Data fetched successfully", { items: data.data?.length || 0 });
      
      // Check if data has the expected format
      if (!data.data) {
        debugLog("API response missing data property", data);
        throw new Error("API response missing data property");
      }
      
      yardData = data.data || [];
      return yardData;
    });
    
    // Fetch task data
    const taskDataPromise = fetchTaskData();
    
    // Wait for both promises to complete
    Promise.all([yardDataPromise, taskDataPromise])
      .then(([yardResult, taskResult]) => {
        debugLog("All data fetched, yard data: " + yardData.length + ", task data: " + taskData.length);
        
        // For each item, fetch appointment data if we have a shipment number
        const appointmentPromises = [];
        
        yardData.forEach(item => {
          const shipmentNo = item.trailer?.shipment_no;
          if (shipmentNo && !appointmentCache[shipmentNo]) {
            appointmentPromises.push(
              fetchAppointmentData(shipmentNo)
                .catch(err => {
                  debugLog('Error fetching appointment for ' + shipmentNo + ':', err.message);
                  return { appointmentTime: null, sectionName: '' };
                })
            );
          }
        });
        
        // Wait for all appointment data to be fetched
        if (appointmentPromises.length > 0) {
          debugLog('Fetching ' + appointmentPromises.length + ' appointment records...');
          
          Promise.allSettled(appointmentPromises)
            .then(() => {
              debugLog("All appointment data fetched");
              updateTable();
            });
        } else {
          updateTable();
        }
      })
      .catch(error => {
        debugLog("Error in data fetching: ", error.message);
        console.error("Error in data fetching: ", error);
        
        // If yard data exists but task data fails, still update the table
        if (yardData.length > 0) {
          updateTable();
        }
      });
  }

  // Sort data based on current sort configuration
  function sortData(data) {
    if (!sortConfig.column) return data;
    
    return [...data].sort((a, b) => {
      let aValue, bValue;
      
      // Extract values based on column
      switch(sortConfig.column) {
        case 0: // Folio
          aValue = a.trailer?.shipment_details?.reference_1 || '';
          bValue = b.trailer?.shipment_details?.reference_1 || '';
          break;
        case 1: // Entrega
          aValue = a.trailer?.shipment_details?.reference_2 || '';
          bValue = b.trailer?.shipment_details?.reference_2 || '';
          break;
        case 2: // Estado
          aValue = a.status || '';
          bValue = b.status || '';
          break;
        case 3: // Material
          aValue = a.commodity || '';
          bValue = b.commodity || '';
          break;
        case 4: // Descripci√≥n
          aValue = a.trailer?.shipment_details?.sku?.join(', ') || '';
          bValue = b.trailer?.shipment_details?.sku?.join(', ') || '';
          break;
        case 5: // Tipo
          aValue = a.trailer?.service_type || '';
          bValue = b.trailer?.service_type || '';
          break;
        case 6: // Ubicaci√≥n actual
          aValue = a.current_location || '';
          bValue = b.current_location || '';
          break;
        case 7: // Linea
          aValue = a.cab?.carrier || '';
          bValue = b.cab?.carrier || '';
          break;
        case 8: // Nombre operador
          aValue = ((a.cab?.first_name || '') + ' ' + (a.cab?.last_name || '')).trim();
          bValue = ((b.cab?.first_name || '') + ' ' + (b.cab?.last_name || '')).trim();
          break;
        case 9: // Tel√©fono operador
          aValue = a.cab?.driver_cell_no || '';
          bValue = b.cab?.driver_cell_no || '';
          break;
        case 10: // Econ√≥mico tracto
          aValue = a.cab?.cab_no || '';
          bValue = b.cab?.cab_no || '';
          break;
        case 11: // Econ√≥mico trailer
          aValue = a.name || '';
          bValue = b.name || '';
          break;
        case 12: // Hora reportado
          aValue = a.arrival_time || 0;
          bValue = b.arrival_time || 0;
          break;
        case 13: // Tiempo de estancia
          aValue = a.arrival_time || 0;
          bValue = b.arrival_time || 0;
          break;
        case 14: // Fecha de la cita
          const shipmentNoA = a.trailer?.shipment_no || '';
          const shipmentNoB = b.trailer?.shipment_no || '';
          aValue = appointmentCache[shipmentNoA]?.appointmentTime || 0;
          bValue = appointmentCache[shipmentNoB]?.appointmentTime || 0;
          break;
        case 15: // Diferencia vs. cita
          // Sort by absolute difference value
          const shipmentNo1 = a.trailer?.shipment_no || '';
          const shipmentNo2 = b.trailer?.shipment_no || '';
          const apptTimeA = appointmentCache[shipmentNo1]?.appointmentTime || 0;
          const apptTimeB = appointmentCache[shipmentNo2]?.appointmentTime || 0;
          aValue = apptTimeA && a.arrival_time ? Math.abs(apptTimeA - a.arrival_time) : Number.MAX_SAFE_INTEGER;
          bValue = apptTimeB && b.arrival_time ? Math.abs(apptTimeB - b.arrival_time) : Number.MAX_SAFE_INTEGER;
          break;
        case 16: // Secci√≥n cita
          const shipmentNoSectionA = a.trailer?.shipment_no || '';
          const shipmentNoSectionB = b.trailer?.shipment_no || '';
          aValue = appointmentCache[shipmentNoSectionA]?.sectionName || '';
          bValue = appointmentCache[shipmentNoSectionB]?.sectionName || '';
          break;
        case 17: // Aviso enviado
          aValue = extractNotificationTime(a) || 0;
          bValue = extractNotificationTime(b) || 0;
          break;
        case 18: // Hora de ingreso
          aValue = getTaskTimeForAsset(a.uuid, 'spot', 'created_time') || 0;
          bValue = getTaskTimeForAsset(b.uuid, 'spot', 'created_time') || 0;
          break;
        case 19: // Hora de llegada a rampa
          aValue = getTaskTimeForAsset(a.uuid, 'spot', 'completed_time') || 0;
          bValue = getTaskTimeForAsset(b.uuid, 'spot', 'completed_time') || 0;
          break;
        case 20: // Hora de fin de carga/descarga
          aValue = getTaskTimeForAsset(a.uuid, 'pull', 'created_time') || 0;
          bValue = getTaskTimeForAsset(b.uuid, 'pull', 'created_time') || 0;
          break;
        case 21: // Hora de salida de rampa
          aValue = getTaskTimeForAsset(a.uuid, 'pull', 'completed_time') || 0;
          bValue = getTaskTimeForAsset(b.uuid, 'pull', 'completed_time') || 0;
          break;
        default:
          return 0;
      }
      
      // Numeric comparison for numbers
      if (!isNaN(aValue) && !isNaN(bValue)) {
        aValue = parseFloat(aValue);
        bValue = parseFloat(bValue);
      }
      
      // Perform the comparison
      const result = 
        aValue > bValue ? 1 :
        aValue < bValue ? -1 : 0;
        
      // Reverse if direction is descending
      return sortConfig.direction === 'asc' ? result : -result;
    });
  }

  // Filter data based on current filter values
  function filterData(data) {
    return data.filter(item => {
      for (const columnIndex in filters) {
        if (!filters[columnIndex] || filters[columnIndex] === '') continue;
        
        const filterText = filters[columnIndex].toLowerCase();
        let itemValue = '';
        
        // Extract values based on column
        switch(parseInt(columnIndex)) {
          case 0: // Folio
            itemValue = item.trailer?.shipment_details?.reference_1 || '';
            break;
          case 1: // Entrega
            itemValue = item.trailer?.shipment_details?.reference_2 || '';
            break;
          case 2: // Estado
            itemValue = item.status === 'empty' ? 'vac√≠o' : item.status === 'loaded' ? 'cargado' : item.status || '';
            break;
          case 3: // Material
            itemValue = item.commodity || '';
            break;
          case 4: // Descripci√≥n
            itemValue = item.trailer?.shipment_details?.sku?.join(', ') || '';
            break;
          case 5: // Tipo
            itemValue = item.trailer?.service_type || '';
            break;
          case 6: // Ubicaci√≥n actual
            itemValue = item.current_location || '';
            break;
          case 7: // Linea
            itemValue = item.cab?.carrier || '';
            break;
          case 8: // Nombre operador
            itemValue = ((item.cab?.first_name || '') + ' ' + (item.cab?.last_name || '')).trim();
            break;
          case 9: // Tel√©fono operador
            itemValue = item.cab?.driver_cell_no || '';
            break;
          case 10: // Econ√≥mico tracto
            itemValue = item.cab?.cab_no || '';
            break;
          case 11: // Econ√≥mico trailer
            itemValue = item.name || '';
            break;
          case 12: // Hora reportado
            itemValue = formatTimestamp(item.arrival_time);
            break;
          case 13: // Tiempo de estancia
            itemValue = calculateDwellTime(item.arrival_time).split(' ')[0]; // Remove emoji
            break;
          case 14: // Fecha de la cita
            const shipmentNo = item.trailer?.shipment_no || '';
            const apptTime = appointmentCache[shipmentNo]?.appointmentTime;
            itemValue = apptTime ? formatTimestamp(apptTime) : '';
            break;
          case 15: // Diferencia vs. cita
            const shipmentNoDiff = item.trailer?.shipment_no || '';
            const apptTimeDiff = appointmentCache[shipmentNoDiff]?.appointmentTime;
            itemValue = (apptTimeDiff && item.arrival_time) ? 
                       calculateTimeDifference(item.arrival_time, apptTimeDiff) : '';
            break;
          case 16: // Secci√≥n cita
            const shipmentNoSection = item.trailer?.shipment_no || '';
            itemValue = appointmentCache[shipmentNoSection]?.sectionName || '';
            break;
          case 17: // Aviso enviado
            const notificationTime = extractNotificationTime(item);
            itemValue = notificationTime ? formatTimestamp(notificationTime) : 'No enviado';
            break;
          case 18: // Hora de ingreso
            const ingressTime = getTaskTimeForAsset(item.uuid, 'spot', 'created_time');
            itemValue = ingressTime ? formatTimestamp(ingressTime) : '';
            break;
          case 19: // Hora de llegada a rampa
            const arrivalTime = getTaskTimeForAsset(item.uuid, 'spot', 'completed_time');
            itemValue = arrivalTime ? formatTimestamp(arrivalTime) : '';
            break;
          case 20: // Hora de fin de carga/descarga
            const endLoadingTime = getTaskTimeForAsset(item.uuid, 'pull', 'created_time');
            itemValue = endLoadingTime ? formatTimestamp(endLoadingTime) : '';
            break;
          case 21: // Hora de salida de rampa
            const exitTime = getTaskTimeForAsset(item.uuid, 'pull', 'completed_time');
            itemValue = exitTime ? formatTimestamp(exitTime) : '';
            break;
          default:
            itemValue = '';
        }
        
        if (!itemValue.toLowerCase().includes(filterText)) {
          return false;
        }
      }
      
      return true;
    });
  }

  // Get data that is both filtered and sorted
  function getFilteredAndSortedData() {
    const filtered = filterData(yardData);
    return sortData(filtered);
  }

  // Update the table with fetched yard data
  function updateTable() {
    if (!modalCreated) {
      debugLog("Modal not created yet, skipping table update");
      return;
    }
    
    const tableBody = document.getElementById('yard-table-body');
    if (!tableBody) {
      debugLog("Table body element not found");
      return;
    }
    
    debugLog('Updating table with ' + yardData.length + ' rows');
    tableBody.innerHTML = '';
    
    if (yardData.length === 0) {
      const emptyRow = document.createElement('tr');
      emptyRow.innerHTML = '<td colspan="22" style="text-align: center; padding: 20px;">No hay datos disponibles</td>';
      tableBody.appendChild(emptyRow);
      return;
    }
    
    // Get filtered and sorted data
    const displayData = getFilteredAndSortedData();
    
    if (displayData.length === 0) {
      const emptyRow = document.createElement('tr');
      emptyRow.innerHTML = '<td colspan="22" style="text-align: center; padding: 20px;">No hay resultados para los filtros actuales</td>';
      tableBody.appendChild(emptyRow);
      return;
    }
    
    displayData.forEach((item, index) => {
      try {
        const row = document.createElement('tr');
        
        // Check if comment contains <critico> tag
        const isCritical = (item.trailer && item.trailer.comment && item.trailer.comment.includes('<critico>')) ||
                           (item.comment && item.comment.includes('<critico>'));
        
        if (isCritical) {
          // Apply vibrant red background and yellow text for critical items
          row.style.backgroundColor = '#ff0000'; // Vibrant red
          row.style.color = '#ffff00'; // Yellow text
          row.style.fontWeight = 'bold';
        } else {
          // Color rows differently based on status or other criteria
          const status = item.status || '';
          const serviceType = item.trailer?.service_type || '';
          const shipmentNo = item.trailer?.shipment_no || '';
          const appointmentInfo = appointmentCache[shipmentNo] || { appointmentTime: null, sectionName: '' };
          
          // Set row colors based on status and service type
          if (status === 'empty') {
            row.style.backgroundColor = '#e8f5e9'; // Light green for empty
          } else if (status === 'loaded') {
            row.style.backgroundColor = '#fff8e1'; // Light yellow for loaded
          }
          
          // If appointment is set, give different color
          if (appointmentInfo.appointmentTime) {
            // Check if past appointment time
            if (Date.now() > appointmentInfo.appointmentTime) {
              row.style.backgroundColor = '#ffebee'; // Light red for past appointment
            }
          }
          
          // Alternate row colors slightly for better readability
          if (index % 2 === 1) {
            // Make the background slightly darker
            const currentBg = row.style.backgroundColor || '#ffffff';
            const darkerBg = adjustBrightness(currentBg, -5);
            row.style.backgroundColor = darkerBg;
          }
        }
        
        // Get nested values with safe access
        const reference1 = item.trailer && item.trailer.shipment_details ? item.trailer.shipment_details.reference_1 || '' : '';
        const reference2 = item.trailer && item.trailer.shipment_details ? item.trailer.shipment_details.reference_2 || '' : '';
        const statusText = item.status === 'empty' ? 'Vac√≠o' : item.status === 'loaded' ? 'Cargado' : item.status || '';
        const commodity = item.commodity || '';
        const sku = item.trailer && item.trailer.shipment_details && item.trailer.shipment_details.sku ? 
                    item.trailer.shipment_details.sku.join(', ') : '';
        const serviceTypeText = item.trailer ? item.trailer.service_type || '' : '';
        const location = item.current_location || '';
        const carrier = item.cab ? item.cab.carrier || '' : '';
        const driverName = item.cab ? 
                          (item.cab.first_name || '') + ' ' + (item.cab.last_name || '').trim() : '';
        const driverPhone = item.cab ? item.cab.driver_cell_no || '' : '';
        const cabNo = item.cab ? item.cab.cab_no || '' : '';
        const trailerName = item.name || '';
        const arrivalTime = formatTimestamp(item.arrival_time);
        const timeDifference = calculateDwellTime(item.arrival_time);
        
        // Appointment data
        const appointmentInfo = appointmentCache[item.trailer?.shipment_no || ''] || { appointmentTime: null, sectionName: '' };
        const appointmentTime = appointmentInfo.appointmentTime ? formatTimestamp(appointmentInfo.appointmentTime) : '';
        const appointmentDiff = (item.arrival_time && appointmentInfo.appointmentTime) ? 
                               calculateTimeDifference(item.arrival_time, appointmentInfo.appointmentTime) : '';
        const sectionName = appointmentInfo.sectionName || '';
        
        // Notification data
        const notificationTime = extractNotificationTime(item);
        
        // Task data
        const ingressTime = getTaskTimeForAsset(item.uuid, 'spot', 'created_time');
        const arrivalToRampTime = getTaskTimeForAsset(item.uuid, 'spot', 'completed_time');
        const endLoadingTime = getTaskTimeForAsset(item.uuid, 'pull', 'created_time');
        const exitRampTime = getTaskTimeForAsset(item.uuid, 'pull', 'completed_time');
        
        // Create cells
        const tdReference1 = document.createElement('td');
        tdReference1.textContent = reference1;
        
        const tdReference2 = document.createElement('td');
        tdReference2.textContent = reference2;
        
        const tdStatus = document.createElement('td');
        tdStatus.textContent = statusText;
        
        const tdCommodity = document.createElement('td');
        tdCommodity.textContent = commodity;
        
        const tdSku = document.createElement('td');
        tdSku.textContent = sku;
        
        const tdServiceType = document.createElement('td');
        tdServiceType.textContent = serviceTypeText;
        
        const tdLocation = document.createElement('td');
        tdLocation.textContent = location;
        
        const tdCarrier = document.createElement('td');
        tdCarrier.textContent = carrier;
        
        const tdDriverName = document.createElement('td');
        tdDriverName.textContent = driverName;
        
        const tdDriverPhone = document.createElement('td');
        tdDriverPhone.textContent = driverPhone;
        
        const tdCabNo = document.createElement('td');
        tdCabNo.textContent = cabNo;
        
        const tdTrailerName = document.createElement('td');
        tdTrailerName.textContent = trailerName;
        
        const tdArrivalTime = document.createElement('td');
        tdArrivalTime.textContent = arrivalTime;
        
        const tdTimeDifference = document.createElement('td');
        tdTimeDifference.className = 'time-diff';
        tdTimeDifference.innerHTML = timeDifference;
        
        // Appointment columns
        const tdAppointmentTime = document.createElement('td');
        tdAppointmentTime.textContent = appointmentTime;
        
        const tdAppointmentDiff = document.createElement('td');
        tdAppointmentDiff.textContent = appointmentDiff;
        
        const tdSectionName = document.createElement('td');
        tdSectionName.textContent = sectionName;
        
        // Notification column
        const tdNotification = document.createElement('td');
        if (notificationTime) {
          tdNotification.textContent = formatTimestamp(notificationTime);
        } else {
          const notifyButton = document.createElement('button');
          notifyButton.textContent = 'Aviso';
          notifyButton.className = 'notify-button';
          notifyButton.style.cssText = `
            padding: 4px 8px;
            background-color: #f44336;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
          `;
          notifyButton.onclick = function() {
            this.disabled = true;
            this.textContent = 'Enviando...';
            
            sendNotification(item)
              .then(() => {
                // Button will be replaced by timestamp on table update
              })
              .catch(err => {
                this.disabled = false;
                this.textContent = 'Reintentar';
                alert('Error enviando aviso: ' + err.message);
              });
          };
          tdNotification.appendChild(notifyButton);
        }
        
        // Task data columns
        const tdIngressTime = document.createElement('td');
        tdIngressTime.textContent = ingressTime ? formatTimestamp(ingressTime) : '';
        
        const tdArrivalToRampTime = document.createElement('td');
        tdArrivalToRampTime.textContent = arrivalToRampTime ? formatTimestamp(arrivalToRampTime) : '';
        
        const tdEndLoadingTime = document.createElement('td');
        tdEndLoadingTime.textContent = endLoadingTime ? formatTimestamp(endLoadingTime) : '';
        
        const tdExitRampTime = document.createElement('td');
        tdExitRampTime.textContent = exitRampTime ? formatTimestamp(exitRampTime) : '';
        
        // Append all cells to the row
        row.appendChild(tdReference1);
        row.appendChild(tdReference2);
        row.appendChild(tdStatus);
        row.appendChild(tdCommodity);
        row.appendChild(tdSku);
        row.appendChild(tdServiceType);
        row.appendChild(tdLocation);
        row.appendChild(tdCarrier);
        row.appendChild(tdDriverName);
        row.appendChild(tdDriverPhone);
        row.appendChild(tdCabNo);
        row.appendChild(tdTrailerName);
        row.appendChild(tdArrivalTime);
        row.appendChild(tdTimeDifference);
        row.appendChild(tdAppointmentTime);
        row.appendChild(tdAppointmentDiff);
        row.appendChild(tdSectionName);
        row.appendChild(tdNotification);
        row.appendChild(tdIngressTime);
        row.appendChild(tdArrivalToRampTime);
        row.appendChild(tdEndLoadingTime);
        row.appendChild(tdExitRampTime);
        
        tableBody.appendChild(row);
      } catch (err) {
        debugLog('Error processing row ' + index + ':', err.message);
      }
    });
    
    // Update filter count display
    const statusMsg = document.getElementById('yard-status-message');
    if (statusMsg) {
      const statusSpan = statusMsg.querySelector('span');
      if (statusSpan) {
        if (displayData.length < yardData.length) {
          statusSpan.textContent = 'Mostrando ' + displayData.length + ' de ' + yardData.length + ' registros (filtrados)';
        } else {
          statusSpan.textContent = 'Mostrando ' + yardData.length + ' registros';
        }
      }
    }
    
    debugLog("Table updated successfully");
  }

  // Adjust color brightness (for row highlighting)
  function adjustBrightness(color, percent) {
    if (!color || color === 'transparent') return '#f5f5f5';
    
    // Handle named colors
    if (color.indexOf('#') !== 0) {
      const tempElem = document.createElement('div');
      tempElem.style.color = color;
      document.body.appendChild(tempElem);
      const computedColor = getComputedStyle(tempElem).color;
      document.body.removeChild(tempElem);
      
      // Convert rgb to hex
      if (computedColor.indexOf('rgb') === 0) {
        const rgb = computedColor.match(/\d+/g);
        if (rgb && rgb.length >= 3) {
          color = '#' + 
            parseInt(rgb[0]).toString(16).padStart(2, '0') +
            parseInt(rgb[1]).toString(16).padStart(2, '0') +
            parseInt(rgb[2]).toString(16).padStart(2, '0');
        } else {
          return '#f5f5f5';
        }
      } else {
        return '#f5f5f5';
      }
    }
    
    let R = parseInt(color.substring(1,3), 16);
    let G = parseInt(color.substring(3,5), 16);
    let B = parseInt(color.substring(5,7), 16);

    R = parseInt(R * (100 + percent) / 100);
    G = parseInt(G * (100 + percent) / 100);
    B = parseInt(B * (100 + percent) / 100);

    R = (R < 255) ? R : 255;  
    G = (G < 255) ? G : 255;  
    B = (B < 255) ? B : 255;  

    const RR = ((R.toString(16).length === 1) ? "0" + R.toString(16) : R.toString(16));
    const GG = ((G.toString(16).length === 1) ? "0" + G.toString(16) : G.toString(16));
    const BB = ((B.toString(16).length === 1) ? "0" + B.toString(16) : B.toString(16));

    return "#"+RR+GG+BB;
  }

  // Update only the time difference cells to avoid full table rerender
  function updateTimeDiffCells() {
    const timeDiffCells = document.querySelectorAll('.time-diff');
    
    // Get filtered and sorted data
    const displayData = getFilteredAndSortedData();
    
    displayData.forEach((item, index) => {
      if (index < timeDiffCells.length && item.arrival_time) {
        timeDiffCells[index].innerHTML = calculateDwellTime(item.arrival_time);
      }
    });
  }

  // Create column header with sort capabilities
  function createSortableHeader(text, columnIndex) {
    const th = document.createElement('th');
    th.style.cssText = `
      position: relative;
      cursor: pointer;
      padding-right: 20px;
      background-color: #4185f4;
    `;
    
    // Header text content
    const headerText = document.createElement('span');
    headerText.textContent = text;
    th.appendChild(headerText);
    
    // Sort indicator
    const sortIndicator = document.createElement('span');
    sortIndicator.style.cssText = `
      position: absolute;
      right: 5px;
      top: 50%;
      transform: translateY(-50%);
      font-size: 12px;
    `;
    
    // Update sort indicator based on current sort config
    if (sortConfig.column === columnIndex) {
      sortIndicator.textContent = sortConfig.direction === 'asc' ? '‚Üë' : '‚Üì';
    }
    th.appendChild(sortIndicator);
    
    // Filter input
    const filterInput = document.createElement('input');
    filterInput.type = 'text';
    filterInput.placeholder = 'Filtrar...';
    filterInput.style.cssText = `
      display: block;
      width: calc(100% - 10px);
      margin-top: 4px;
      padding: 4px;
      box-sizing: border-box;
      font-size: 12px;
      color: #333;
    `;
    
    // Set initial filter value
    if (filters[columnIndex]) {
      filterInput.value = filters[columnIndex];
    }
    
    // Add input event listener
    filterInput.addEventListener('input', function() {
      filters[columnIndex] = this.value;
      updateTable();
    });
    
    th.appendChild(filterInput);
    
    // Add click event for sorting
    th.addEventListener('click', function(e) {
      // Don't trigger sort when clicking on the filter input
      if (e.target === filterInput) return;
      
      // Toggle sort direction or set new column
      if (sortConfig.column === columnIndex) {
        sortConfig.direction = sortConfig.direction === 'asc' ? 'desc' : 'asc';
      } else {
        sortConfig.column = columnIndex;
        sortConfig.direction = 'asc';
      }
      
      // Update all sort indicators
      document.querySelectorAll('th span:last-child').forEach((indicator, idx) => {
        if (idx !== columnIndex) {
          indicator.textContent = '';
        } else {
          indicator.textContent = sortConfig.direction === 'asc' ? '‚Üë' : '‚Üì';
        }
      });
      
      updateTable();
    });
    
    return th;
  }

  // Create and show the console modal
  function showConsole() {
    debugLog("Showing console modal");
    
    if (modalCreated) {
      document.getElementById('yard-console-modal').style.display = 'block';
      return;
    }
    
    const modal = document.createElement('div');
    modal.id = 'yard-console-modal';
    modal.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: white;
      z-index: 10001;
      display: flex;
      flex-direction: column;
      padding: 20px;
      box-sizing: border-box;
      overflow: auto;
    `;
    
    const header = document.createElement('div');
    header.style.cssText = `
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    `;
    
    const title = document.createElement('h1');
    title.textContent = 'Estado de Patio';
    title.style.margin = '0';
    
    const controlsDiv = document.createElement('div');
    
    // Add refresh button
    const refreshBtn = document.createElement('button');
    refreshBtn.textContent = 'Refrescar';
    refreshBtn.style.cssText = `
      margin-right: 10px;
      padding: 5px 15px;
      background-color: #4CAF50;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    `;
    refreshBtn.onclick = () => {
      debugLog("Manual refresh triggered from console");
      fetchYardData(true);
    };
    
    // Add export button
    const exportBtn = document.createElement('button');
    exportBtn.textContent = 'Exportar a Excel';
    exportBtn.style.cssText = `
      margin-right: 10px;
      padding: 5px 15px;
      background-color: #2196F3;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    `;
    exportBtn.onclick = () => {
      // Load XLSX library before exporting
      loadXLSXLibrary()
        .then(() => exportToExcel())
        .catch(() => exportToCSV()); // Fallback to CSV export
    };
    
    const closeBtn = document.createElement('button');
    closeBtn.textContent = 'X';
    closeBtn.style.cssText = `
      background: none;
      border: none;
      font-size: 24px;
      cursor: pointer;
      color: #333;
    `;
    closeBtn.onclick = () => {
      modal.style.display = 'none';
    };
    
    controlsDiv.appendChild(exportBtn);
    controlsDiv.appendChild(refreshBtn);
    controlsDiv.appendChild(closeBtn);
    header.appendChild(title);
    header.appendChild(controlsDiv);
    
    const tableContainer = document.createElement('div');
    tableContainer.style.cssText = `
      overflow-x: auto;
      flex-grow: 1;
    `;
    
    const table = document.createElement('table');
    table.style.cssText = `
      width: 100%;
      border-collapse: collapse;
      font-size: 14px;
    `;
    
    const thead = document.createElement('thead');
    thead.style.cssText = `
      background-color: #4185f4;
      color: white;
      position: sticky;
      top: 0;
    `;
    
    // Create header row with sortable and filterable headers
    const headerRow = document.createElement('tr');
    
    const headers = [
      'Folio', 'Entrega', 'Estado', 'Material', 'Descripci√≥n', 
      'Tipo', 'Ubicaci√≥n actual', 'Linea', 'Nombre operador', 
      'Tel√©fono operador', 'Econ√≥mico tracto', 'Econ√≥mico trailer', 
      'Hora reportado', 'Tiempo de estancia', 'Fecha de la cita',
      'Diferencia vs. cita', 'Secci√≥n cita', 'Aviso enviado',
      'Hora de ingreso', 'Hora de llegada a rampa',
      'Hora de fin de carga/descarga', 'Hora de salida de rampa'
    ];
    
    headers.forEach((headerText, index) => {
      const th = createSortableHeader(headerText, index);
      headerRow.appendChild(th);
    });
    
    thead.appendChild(headerRow);
    
    const tbody = document.createElement('tbody');
    tbody.id = 'yard-table-body';
    tbody.style.cssText = `
      tr:hover {
        background-color: #f1f8ff !important;
      }
      td {
        padding: 8px;
        border: 1px solid #ddd;
      }
    `;
    
    table.appendChild(thead);
    table.appendChild(tbody);
    tableContainer.appendChild(table);
    
    modal.appendChild(header);
    modal.appendChild(tableContainer);
    document.body.appendChild(modal);
    
    modalCreated = true;
    debugLog("Modal created");
    
    // Add status message element
    const statusMsg = document.createElement('div');
    statusMsg.id = 'yard-status-message';
    statusMsg.style.cssText = `
      padding: 10px;
      margin-bottom: 10px;
      background-color: #f8f9fa;
      border-radius: 4px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    `;
    
    // Create status message without template literals
    const statusSpan = document.createElement('span');
    statusSpan.textContent = 'Cargando datos del patio...';
    
    const statusInfo = document.createElement('div');
    statusInfo.innerHTML = 
      '<strong>Auth:</strong> ' + (authorization ? '‚úÖ' : '‚ùå') + 
      ' <strong>Cookie:</strong> ' + (cookieValue ? '‚úÖ' : '‚ùå');
    
    statusMsg.appendChild(statusSpan);
    statusMsg.appendChild(statusInfo);
    
    modal.insertBefore(statusMsg, tableContainer);
    
    fetchYardData();
    
    // Start refreshing time difference every second
    if (refreshIntervalId) {
      clearInterval(refreshIntervalId);
    }
    refreshIntervalId = setInterval(updateTimeDiffCells, 1000);
    
    // Display sample data if no real data available after 3 seconds
    setTimeout(() => {
      if (yardData.length === 0) {
        debugLog("No data after timeout, using fallback sample data");
        yardData = createSampleData();
        updateTable();
      }
    }, 3000);
  }

  // Create sample data for testing
  function createSampleData() {
    const now = Date.now();
    const oneHourAgo = now - 3600000;
    const twoHoursAgo = now - 7200000;
    const fiveHoursAgo = now - 18000000;

    // Sample appointment times
    const sampleAppointment1 = now + 1800000; // 30 minutes in future
    const sampleAppointment2 = oneHourAgo - 1800000; // 30 minutes before oneHourAgo
    
    const samples = [
      {
        trailer: {
          shipment_details: {
            reference_1: "10789315",
            reference_2: "ib-0226605606",
            sku: ["000000000002010099-env mod especial 12 oz granel premium"]
          },
          service_type: "inbound",
          shipment_no: "10789315_1",
          comment: "<a><b>angel</b><c>espinoza</c><d></d><e></e><f></f><g></g><h></h><i>380</i><j></j><k>2017</k><l>kenworth</l><m>20942063</m><n>y2a0ct</n><o>2012</o><p>hytr</p><u>mxtraabe</u><s1>1736790117367902</s1><critico></critico></a>\n<q></q>\n<r></r>\n<s></s>\n<t></t>\n<s2></s2><sc>1752651400000</sc>"
        },
        status: "empty",
        commodity: "envaselv03",
        current_location: "llegada1",
        cab: {
          carrier: "mxtraabe",
          first_name: "angel",
          last_name: "espinoza",
          driver_cell_no: "6221478130",
          cab_no: "380"
        },
        name: "20942063",
        arrival_time: now - 1800000, // 30 minutes ago
        uuid: "sample-uuid-1"
      },
      {
        trailer: {
          shipment_details: {
            reference_1: "10767178",
            reference_2: "ib-0226430389"
          },
          service_type: "inbound",
          shipment_no: "10767178_1"
        },
        status: "loaded",
        commodity: "envaselv03im",
        current_location: "stg-09",
        cab: {
          carrier: "xpog",
          first_name: "natividad",
          last_name: "bojorquez",
          driver_cell_no: "6681701792",
          cab_no: "23"
        },
        name: "411422",
        arrival_time: oneHourAgo,
        uuid: "sample-uuid-2"
      },
      {
        trailer: {
          shipment_details: {
            reference_1: "10767172",
            reference_2: "ib-0226430364",
            sku: ["000000000002010099-btl mod esp 12oz bulk premium"]
          },
          service_type: "inbound",
          shipment_no: "10767172_2"
        },
        status: "loaded",
        commodity: "envaselv03im",
        current_location: "stg-22",
        cab: {
          carrier: "xpog",
          first_name: "raul",
          last_name: "tejada",
          driver_cell_no: "6441500367",
          cab_no: "t04"
        },
        name: "412616",
        arrival_time: twoHoursAgo,
        uuid: "sample-uuid-3"
      },
      {
        trailer: {
          service_type: "outbound",
          shipment_no: "10767171_1"
        },
        status: "empty",
        current_location: "cpt2-08",
        cab: {
          carrier: "leyva",
          cab_no: "ley07"
        },
        name: "07",
        arrival_time: fiveHoursAgo,
        uuid: "sample-uuid-4"
      }
    ];
    
    // Add sample appointment data to cache
    appointmentCache["10789315_1"] = {
      appointmentTime: sampleAppointment1,
      sectionName: "pt 1"
    };
    
    appointmentCache["10767178_1"] = {
      appointmentTime: sampleAppointment2,
      sectionName: "pt 2"
    };
    
    // Add sample task data
    taskData = [
      {
        task_type: {
          code: "spot",
        },
        created_time: now - 2000000,
        completed_time: now - 1800000,
        assets: [{ uuid: "sample-uuid-1" }]
      },
      {
        task_type: {
          code: "pull",
        },
        created_time: now - 1000000,
        completed_time: now - 800000,
        assets: [{ uuid: "sample-uuid-1" }]
      },
      {
        task_type: {
          code: "spot",
        },
        created_time: now - 4000000,
        completed_time: now - 3800000,
        assets: [{ uuid: "sample-uuid-2" }]
      },
      {
        task_type: {
          code: "pull",
        },
        created_time: now - 3000000,
        completed_time: now - 2800000,
        assets: [{ uuid: "sample-uuid-2" }]
      }
    ];
    
    return samples;
  }

  // Intercept XHR requests to capture authorization and cookies
  function interceptXHR() {
    debugLog("Setting up XHR interception");
    
    const origOpen = XMLHttpRequest.prototype.open;
    XMLHttpRequest.prototype.open = function() {
      this.addEventListener('load', function() {
        if (this.responseURL && this.responseURL.includes('yard-visibility-na12.api.project44.com')) {
          debugLog('XHR intercepted: ' + this.responseURL);
          
          // Get the request headers from the original request
          try {
            const authHeader = this._requestHeaders?.find(h => h.name === 'Authorization')?.value;
            const cookieHeader = this._requestHeaders?.find(h => h.name === 'Cookie')?.value;
            
            if (authHeader) {
              authorization = authHeader;
              debugLog("Authorization captured from XHR");
            }
            
            if (cookieHeader) {
              cookieValue = cookieHeader;
              debugLog("Cookie captured from XHR");
            }
            
            if (authorization && cookieValue && !yardData.length) {
              fetchYardData();
            }
          } catch (e) {
            debugLog("Error extracting headers:", e.message);
          }
        }
      });
      origOpen.apply(this, arguments);
    };
    
    // Store original setRequestHeader
    const origSetRequestHeader = XMLHttpRequest.prototype.setRequestHeader;
    XMLHttpRequest.prototype.setRequestHeader = function(header, value) {
      // Store headers for later use
      if (!this._requestHeaders) this._requestHeaders = [];
      this._requestHeaders.push({ name: header, value: value });
      
      if (header.toLowerCase() === 'authorization' && value) {
        authorization = value;
        debugLog("Authorization captured from setRequestHeader");
      }
      
      if (header.toLowerCase() === 'cookie' && value) {
        cookieValue = value;
        debugLog("Cookie captured from setRequestHeader");
      }
      
      return origSetRequestHeader.apply(this, arguments);
    };
  }

  // Also intercept fetch requests
  function interceptFetch() {
    debugLog("Setting up fetch interception");
    
    const originalFetch = window.fetch;
    window.fetch = function(url, options = {}) {
      if (url && url.toString().includes('yard-visibility-na12.api.project44.com')) {
        debugLog('Fetch intercepted: ' + url.toString());
        
        if (options.headers) {
          const headers = options.headers instanceof Headers ? 
            Object.fromEntries([...options.headers.entries()]) : 
            options.headers;
            
          if (headers.Authorization || headers.authorization) {
            authorization = headers.Authorization || headers.authorization;
            debugLog("Authorization captured from fetch");
          }
          
          if (headers.Cookie || headers.cookie) {
            cookieValue = headers.Cookie || headers.cookie;
            debugLog("Cookie captured from fetch");
          }
        }
      }
      return originalFetch.apply(this, arguments);
    };
  }

  // Extract cookies from document
  function extractCookies() {
    debugLog("Attempting to extract cookies from document");
    if (document.cookie) {
      cookieValue = document.cookie;
      debugLog("Cookies extracted from document");
    } else {
      debugLog("No cookies found in document");
    }
  }

  // Get token from local storage
  function getTokenFromStorage() {
    debugLog("Attempting to get token from storage");
    try {
      // Check for common token storage patterns
      const storageKeys = ['token', 'accessToken', 'jwt', 'authToken', 'p44_token', 'yard_token'];
      
      for (let key of storageKeys) {
        const token = localStorage.getItem(key) || sessionStorage.getItem(key);
        if (token) {
          authorization = 'Bearer ' + token;
          debugLog('Token found in storage: ' + key);
          return true;
        }
      }
      
      // Try to find token in any storage key
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        const value = localStorage.getItem(key);
        
        if (typeof value === 'string' && (
            value.startsWith('eyJ') || 
            value.includes('token') || 
            key.includes('token') || 
            key.includes('auth')
        )) {
          debugLog('Potential token found in localStorage: ' + key);
          if (value.startsWith('Bearer ')) {
            authorization = value;
          } else if (value.startsWith('eyJ')) {
            authorization = 'Bearer ' + value;
          }
          return true;
        }
      }
      
      debugLog("No token found in storage");
      return false;
    } catch (e) {
      debugLog("Error accessing storage:", e.message);
      return false;
    }
  }

  // Initialize the script
  function init() {
    debugLog("Initializing Yard Console");
    createButton();
    interceptXHR();
    interceptFetch();
    extractCookies();
    getTokenFromStorage();
    
    // Try to fetch data every 30 seconds if auth is available
    setInterval(() => {
      if (authorization && cookieValue) {
        fetchYardData();
      }
    }, 30000);
    
    debugLog("Initialization complete");
  }

  // Run the init function
  init();
})();
